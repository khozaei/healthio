// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: receptions.sql

package model

import (
	"context"
	"database/sql"
	"time"
)

const addReception = `-- name: AddReception :execresult
INSERT INTO receptions(reception_date, reception_time, visit_duration,
            insurance_code, description, created_at, patient_id)
VALUES(?, ?, ?, ?, ?, ?, ?)
`

type AddReceptionParams struct {
	ReceptionDate time.Time
	ReceptionTime time.Time
	VisitDuration int32
	InsuranceCode sql.NullString
	Description   sql.NullString
	CreatedAt     time.Time
	PatientID     int64
}

func (q *Queries) AddReception(ctx context.Context, arg AddReceptionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, addReception,
		arg.ReceptionDate,
		arg.ReceptionTime,
		arg.VisitDuration,
		arg.InsuranceCode,
		arg.Description,
		arg.CreatedAt,
		arg.PatientID,
	)
}

const deleteReception = `-- name: DeleteReception :exec
UPDATE receptions SET
    deleted_at = ?
WHERE id = ?
`

type DeleteReceptionParams struct {
	DeletedAt sql.NullTime
	ID        int64
}

func (q *Queries) DeleteReception(ctx context.Context, arg DeleteReceptionParams) error {
	_, err := q.db.ExecContext(ctx, deleteReception, arg.DeletedAt, arg.ID)
	return err
}

const findReceptionsByPatient = `-- name: FindReceptionsByPatient :many
SELECT r.id, reception_date, reception_time, visit_duration, insurance_code, description, r.created_at, r.updated_at, r.deleted_at, patient_id, p.id, first_name, last_name, father_name, phone, national_code, identity_code, p.created_at, p.updated_at, p.deleted_at FROM receptions AS r join patients AS p on r.patient_id = p.id 
WHERE r.deleted_at IS NULL AND 
    p.deleted_at IS NULL AND 
    (p.last_name LIKE CONCAT('%',?,'%') OR
    p.first_name LIKE CONCAT('%',?,'%') OR
    p.national_code LIKE CONCAT('%',?,'%')) AND
    r.reception_date BETWEEN ? AND ? 
ORDER BY p.last_name LIMIT ? OFFSET ?
`

type FindReceptionsByPatientParams struct {
	CONCAT            interface{}
	CONCAT_2          interface{}
	CONCAT_3          interface{}
	FromReceptionDate time.Time
	ToReceptionDate   time.Time
	Limit             int32
	Offset            int32
}

type FindReceptionsByPatientRow struct {
	ID            int64
	ReceptionDate time.Time
	ReceptionTime time.Time
	VisitDuration int32
	InsuranceCode sql.NullString
	Description   sql.NullString
	CreatedAt     time.Time
	UpdatedAt     sql.NullTime
	DeletedAt     sql.NullTime
	PatientID     int64
	ID_2          int64
	FirstName     sql.NullString
	LastName      sql.NullString
	FatherName    sql.NullString
	Phone         sql.NullString
	NationalCode  sql.NullString
	IdentityCode  sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   sql.NullTime
	DeletedAt_2   sql.NullTime
}

func (q *Queries) FindReceptionsByPatient(ctx context.Context, arg FindReceptionsByPatientParams) ([]FindReceptionsByPatientRow, error) {
	rows, err := q.db.QueryContext(ctx, findReceptionsByPatient,
		arg.CONCAT,
		arg.CONCAT_2,
		arg.CONCAT_3,
		arg.FromReceptionDate,
		arg.ToReceptionDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindReceptionsByPatientRow
	for rows.Next() {
		var i FindReceptionsByPatientRow
		if err := rows.Scan(
			&i.ID,
			&i.ReceptionDate,
			&i.ReceptionTime,
			&i.VisitDuration,
			&i.InsuranceCode,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.PatientID,
			&i.ID_2,
			&i.FirstName,
			&i.LastName,
			&i.FatherName,
			&i.Phone,
			&i.NationalCode,
			&i.IdentityCode,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReceptions = `-- name: GetReceptions :many
SELECT r.id, reception_date, reception_time, visit_duration, insurance_code, description, r.created_at, r.updated_at, r.deleted_at, patient_id, p.id, first_name, last_name, father_name, phone, national_code, identity_code, p.created_at, p.updated_at, p.deleted_at FROM receptions AS r join patients AS p on r.patient_id = p.id 
WHERE r.deleted_at IS NULL AND
    r.reception_date BETWEEN ? AND ? 
ORDER BY r.reception_date LIMIT ? OFFSET ?
`

type GetReceptionsParams struct {
	FromReceptionDate time.Time
	ToReceptionDate   time.Time
	Limit             int32
	Offset            int32
}

type GetReceptionsRow struct {
	ID            int64
	ReceptionDate time.Time
	ReceptionTime time.Time
	VisitDuration int32
	InsuranceCode sql.NullString
	Description   sql.NullString
	CreatedAt     time.Time
	UpdatedAt     sql.NullTime
	DeletedAt     sql.NullTime
	PatientID     int64
	ID_2          int64
	FirstName     sql.NullString
	LastName      sql.NullString
	FatherName    sql.NullString
	Phone         sql.NullString
	NationalCode  sql.NullString
	IdentityCode  sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   sql.NullTime
	DeletedAt_2   sql.NullTime
}

func (q *Queries) GetReceptions(ctx context.Context, arg GetReceptionsParams) ([]GetReceptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getReceptions,
		arg.FromReceptionDate,
		arg.ToReceptionDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReceptionsRow
	for rows.Next() {
		var i GetReceptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ReceptionDate,
			&i.ReceptionTime,
			&i.VisitDuration,
			&i.InsuranceCode,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.PatientID,
			&i.ID_2,
			&i.FirstName,
			&i.LastName,
			&i.FatherName,
			&i.Phone,
			&i.NationalCode,
			&i.IdentityCode,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReception = `-- name: UpdateReception :exec
UPDATE receptions SET
    reception_date = ?,
    reception_time = ?,
    visit_duration = ?,
    insurance_code = ?,
    description = ?,
    updated_at = ?
WHERE id = ?
`

type UpdateReceptionParams struct {
	ReceptionDate time.Time
	ReceptionTime time.Time
	VisitDuration int32
	InsuranceCode sql.NullString
	Description   sql.NullString
	UpdatedAt     sql.NullTime
	ID            int64
}

func (q *Queries) UpdateReception(ctx context.Context, arg UpdateReceptionParams) error {
	_, err := q.db.ExecContext(ctx, updateReception,
		arg.ReceptionDate,
		arg.ReceptionTime,
		arg.VisitDuration,
		arg.InsuranceCode,
		arg.Description,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
